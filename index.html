<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Icesi Globe</title>
  <link href="css/css2.css" rel="stylesheet" />
  <link rel="stylesheet" href="css/choices.min.css" />
  <script src="js/turf.min.js"></script>
  <link rel="stylesheet" href="css/index.css" />
</head>

<body>
  <header>Icesi Globe</header>
  <div id="globeViz"></div>

  <div class="controls">
    <select id="country1"></select>
    <select id="country2"></select>
    <div class="optimization-criteria">
      <label for="criteria">Optimizar por:</label>
      <select id="criteria">
        <option value="price" selected>Precio</option>
        <option value="distance">Distancia</option>
        <option value="time">Tiempo</option>
      </select>
    </div>
    <button id="generateArc">Generar Ruta</button>
  </div>

  <div id="countryModal" class="modal"></div>
  <div id="tripInfo" class="trip-info"></div>

  <script src="js/globe.js"></script>
  <script src="js/choices.min.js"></script>

  <script>
    let arcsData = [];
    let countriesData = {};
    let flightGraph = {};
    let countryCentroids = {};
    let countryNameToIdMap = {};
    let idToCountryNameMap = {};

    function calculateWeight(connection, criteria) {
      switch (criteria) {
        case 'price':
          return connection.price_usd;
        case 'distance':
          const fromName = idToCountryNameMap[connection.from];
          const toName = idToCountryNameMap[connection.to];
          const start = countryCentroids[fromName];
          const end = countryCentroids[toName];
          if (start && end) {
            const startPoint = turf.point(start);
            const endPoint = turf.point(end);
            return turf.distance(startPoint, endPoint);
          }
          return connection.price_usd;
        case 'time':
          const fromCountry = idToCountryNameMap[connection.from];
          const toCountry = idToCountryNameMap[connection.to];
          const startPos = countryCentroids[fromCountry];
          const endPos = countryCentroids[toCountry];
          if (startPos && endPos) {
            const startPt = turf.point(startPos);
            const endPt = turf.point(endPos);
            const dist = turf.distance(startPt, endPt);
            
            return dist / 900;
          }
          return connection.price_usd / 100;
        default:
          return connection.price_usd;
      }
    }

    function dijkstraPath(graph, sourceId, destinationId, criteria = 'price') {
      const distances = {};
      const previous = {};
      const heap = [];

      for (const node in graph) {
        distances[node] = Infinity;
      }

      distances[sourceId] = 0;
      heap.push({ id: sourceId, distance: 0 });

      while (heap.length > 0) {
        heap.sort((a, b) => a.distance - b.distance);
        const { id: currentId, distance: currentDistance } = heap.shift();

        if (currentId === destinationId) break;
        if (!graph[currentId]?.connections) continue;

        for (const [neighborId, connection] of Object.entries(
          graph[currentId].connections
        )) {
          const connectionWithFromTo = {
            ...connection,
            from: currentId,
            to: neighborId
          };
          const edgeWeight = calculateWeight(connectionWithFromTo, criteria);
          const totalDistance = currentDistance + edgeWeight;

          if (totalDistance < distances[neighborId]) {
            distances[neighborId] = totalDistance;
            previous[neighborId] = currentId;
            heap.push({ id: neighborId, distance: totalDistance });
          }
        }
      }

      if (distances[destinationId] === Infinity) return [];

      const path = [];
      let current = destinationId;
      while (current !== sourceId) {
        path.push(current);
        current = previous[current];
        if (!current) return [];
      }
      path.push(sourceId);
      return path.reverse();
    }

    Promise.all([
      fetch("data/countries.json").then((res) => res.json()),
      fetch("data/realistic_flight_graph.json").then((res) => res.json()),
      fetch("data/world_with_ids.json").then((res) => res.json()),
    ]).then(([countries, graph, worldData]) => {
      countriesData = countries;
      flightGraph = graph;

      Object.keys(countriesData).forEach((id) => {
        countryNameToIdMap[countriesData[id].name] = id;
        idToCountryNameMap[id] = countriesData[id].name;
      });

      Object.keys(countriesData).forEach((id) => {
        const country = countriesData[id];
        if (country.lat && country.lon) {
          countryCentroids[country.name] = [country.lon, country.lat];
        }
      });

      const world = Globe()
        .globeImageUrl("water-texture.png")
        .backgroundImageUrl("./night-sky.png")
        .backgroundColor("black")(document.getElementById("globeViz"));

      function centerGlobeView(points) {
        if (!points || points.length === 0) return;
        
        if (points.length === 1) {
          const [lng, lat] = points[0];
          world.pointOfView({ lat, lng, altitude: 2.5 }, 1000);
          return;
        }
        
        let sumLat = 0, sumLng = 0;
        points.forEach(point => {
          sumLng += point[0];
          sumLat += point[1];
        });
        
        const avgLng = sumLng / points.length;
        const avgLat = sumLat / points.length;
        
        let maxDist = 0;
        for (let i = 0; i < points.length; i++) {
          for (let j = i + 1; j < points.length; j++) {
            const startPoint = turf.point(points[i]);
            const endPoint = turf.point(points[j]);
            const dist = turf.distance(startPoint, endPoint);
            maxDist = Math.max(maxDist, dist);
          }
        }
        
        const altitude = Math.max(1.5, Math.min(4, 1.5 + maxDist / 5000));
        
        world.pointOfView({ lat: avgLat, lng: avgLng, altitude }, 1000);
      }

      world
        .polygonsData(worldData.features)
        .polygonCapColor(() => "#183eb4")
        .polygonSideColor(() => "rgba(0, 0, 0, 0.0)")
        .polygonStrokeColor(() => "#020a73")
        .onPolygonClick((feature) => showCountryInfo(feature.properties.name));

      const countryNames = worldData.features.map((f) => f.properties.name).sort();
      const select1 = new Choices("#country1", {
        searchEnabled: true,
        removeItemButton: true,
        placeholderValue: "Selecciona país de origen",
      });
      const select2 = new Choices("#country2", {
        searchEnabled: true,
        removeItemButton: true,
        placeholderValue: "Selecciona país destino",
      });
      select1.setChoices(countryNames.map((name) => ({ value: name, label: name })));
      select2.setChoices(countryNames.map((name) => ({ value: name, label: name })));

      document.getElementById("generateArc").addEventListener("click", () => {
        const country1 = select1.getValue(true);
        const country2 = select2.getValue(true);
        const criteria = document.getElementById("criteria").value;

        if (!country1 || !country2 || country1 === country2) {
          alert("Selecciona dos países diferentes");
          return;
        }

        const id1 = countryNameToIdMap[country1];
        const id2 = countryNameToIdMap[country2];
        const path = dijkstraPath(flightGraph, id1, id2, criteria);

        if (!path.length) {
          alert("No existe una ruta entre estos países.");
          return;
        }

        let totalPrice = 0;
        let totalDistance = 0;
        let totalTime = 0;
        arcsData = [];
        const routePoints = [];

        for (let i = 0; i < path.length - 1; i++) {
          const fromId = path[i];
          const toId = path[i + 1];
          const connection = flightGraph[fromId].connections[toId];

          totalPrice += connection.price_usd;

          const fromName = idToCountryNameMap[fromId];
          const toName = idToCountryNameMap[toId];
          const start = countryCentroids[fromName];
          const end = countryCentroids[toName];

          if (start && end) {
            if (!routePoints.includes(start)) routePoints.push(start);
            if (!routePoints.includes(end)) routePoints.push(end);
            
            const startPoint = turf.point(start);
            const endPoint = turf.point(end);
            const distance = turf.distance(startPoint, endPoint);
            totalDistance += distance;
            totalTime += distance / 900;
            arcsData.push({
              startLat: start[1],
              startLng: start[0],
              endLat: end[1],
              endLng: end[0],
              color: `hsl(${Math.random() * 360}, 70%, 50%)`,
            });
          }
        }

        world
          .arcsData(arcsData)
          .arcAltitudeAutoScale(0.5)
          .arcStroke(0.5)
          .arcDashLength(0.1)
          .arcDashGap(0.03)
          .arcDashAnimateTime(3000);

        const routeNames = new Set(path.map((id) => idToCountryNameMap[id]));
        world.polygonCapColor((feature) =>
          routeNames.has(feature.properties.name) ? "#386ee4" : "#183eb4"
        );

        centerGlobeView(routePoints);

        showTripInfo(country1, country2, totalPrice, totalDistance, path);
      });
    });

    function showTripInfo(from, to, price, distance, path) {
      const infoBox = document.getElementById("tripInfo");
      const flightTime = (distance / 900).toFixed(1);
      const stops = path.map((id) => idToCountryNameMap[id]).join(" → ");
      const criteria = document.getElementById("criteria").value;
      
      let optimizedBy = "";
      switch (criteria) {
        case 'price': optimizedBy = "precio"; break;
        case 'distance': optimizedBy = "distancia"; break;
        case 'time': optimizedBy = "tiempo"; break;
      }

      infoBox.innerHTML = `
      <strong>Información del Viaje</strong>
      <p>Origen: ${from}</p>
      <p>Destino: ${to}</p>
      <p>Ruta optimizada por: ${optimizedBy}</p>
      <p>Ruta: ${stops}</p>
      <p>Precio total: $${price.toFixed(2)} USD</p>
      <p>Distancia total: ${distance.toFixed(2)} km</p>
      <p>Duración estimada: ${flightTime} horas</p>
    `;
      infoBox.style.display = "block";
    }

    function showCountryInfo(countryName) {
      const country = Object.values(countriesData).find((c) => c.name === countryName);
      if (!country) return;

      const modal = document.getElementById("countryModal");
      modal.innerHTML = `
      <div class="modal-content">
        <span class="modal-close">&times;</span>
        <h3>${country.spanish_name}</h3>
        <p><strong>Descripción:</strong> ${country.info.description}</p>
        <p><strong>Clima:</strong> ${country.info.climate}</p>
        <p><strong>Atracciones:</strong> ${country.info.attractions.join(", ")}</p>
        <p><strong>Curiosidades:</strong> ${country.info.curiosities.join(", ")}</p>
      </div>
    `;
      modal.style.display = "block";

      modal.querySelector(".modal-close").addEventListener("click", () => {
        modal.style.display = "none";
      });
    }
  </script>
</body>

</html>
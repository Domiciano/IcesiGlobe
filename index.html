<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Icesi Globe</title>
  <link href="css/css2.css" rel="stylesheet" />
  <link rel="stylesheet" href="css/choices.min.css" />
  <script src="js/turf.min.js"></script>
  <link rel="stylesheet" href="css/index.css" />
</head>

<body>
  <header>Icesi Globe</header>
  <div id="globeViz"></div>

  <div class="controls">
    <select id="country1"></select>
    <select id="country2"></select>
    <div class="optimization-criteria">
      <label for="criteria">Optimizar por:</label>
      <select id="criteria">
        <option value="price" selected>Precio</option>
        <option value="distance">Distancia</option>
        <option value="time">Tiempo</option>
      </select>
    </div>
    <button id="generateArc">Generar Ruta</button>
  </div>

  <div id="countryModal" class="modal"></div>
  <div id="tripInfo" class="trip-info"></div>

  <script src="js/globe.js"></script>
  <script src="js/choices.min.js"></script>

  <script>
    let arcsData = [];
    let countriesData = {};
    let flightGraph = {};
    let countryCentroids = {};
    let countryNameToIdMap = {};
    let idToCountryNameMap = {};

    function calculateWeight(connection, criteria) {
      switch (criteria) {
        case 'price':
          return connection.price_usd;
        case 'distance':
          // Usar la distancia geográfica real entre países
          const fromName = idToCountryNameMap[connection.from];
          const toName = idToCountryNameMap[connection.to];
          const start = countryCentroids[fromName];
          const end = countryCentroids[toName];
          if (start && end) {
            const startPoint = turf.point(start);
            const endPoint = turf.point(end);
            return turf.distance(startPoint, endPoint);
          }
          return connection.price_usd; // Fallback a precio si no hay coordenadas
        case 'time':
          // Estimación de tiempo basada en distancia y velocidad promedio
          const fromCountry = idToCountryNameMap[connection.from];
          const toCountry = idToCountryNameMap[connection.to];
          const startPos = countryCentroids[fromCountry];
          const endPos = countryCentroids[toCountry];
          if (startPos && endPos) {
            const startPt = turf.point(startPos);
            const endPt = turf.point(endPos);
            const dist = turf.distance(startPt, endPt);
            // Tiempo estimado en horas (asumiendo velocidad promedio de 900 km/h)
            return dist / 900;
          }
          return connection.price_usd / 100; // Fallback
        default:
          return connection.price_usd;
      }
    }

    function dijkstraPath(graph, sourceId, destinationId, criteria = 'price') {
      const distances = {};
      const previous = {};
      const heap = [];

      for (const node in graph) {
        distances[node] = Infinity;
      }

      distances[sourceId] = 0;
      heap.push({ id: sourceId, distance: 0 });

      while (heap.length > 0) {
        heap.sort((a, b) => a.distance - b.distance);
        const { id: currentId, distance: currentDistance } = heap.shift();

        if (currentId === destinationId) break;
        if (!graph[currentId]?.connections) continue;

        for (const [neighborId, connection] of Object.entries(
          graph[currentId].connections
        )) {
          // Crear un objeto de conexión con from y to para calculateWeight
          const connectionWithFromTo = {
            ...connection,
            from: currentId,
            to: neighborId
          };
          const edgeWeight = calculateWeight(connectionWithFromTo, criteria);
          const totalDistance = currentDistance + edgeWeight;

          if (totalDistance < distances[neighborId]) {
            distances[neighborId] = totalDistance;
            previous[neighborId] = currentId;
            heap.push({ id: neighborId, distance: totalDistance });
          }
        }
      }

      if (distances[destinationId] === Infinity) return [];

      const path = [];
      let current = destinationId;
      while (current !== sourceId) {
        path.push(current);
        current = previous[current];
        if (!current) return [];
      }
      path.push(sourceId);
      return path.reverse();
    }

    Promise.all([
      fetch("data/countries.json").then((res) => res.json()),
      fetch("data/realistic_flight_graph.json").then((res) => res.json()),
      fetch("data/world_with_ids.json").then((res) => res.json()),
    ]).then(([countries, graph, worldData]) => {
      countriesData = countries;
      flightGraph = graph;

      Object.keys(countriesData).forEach((id) => {
        countryNameToIdMap[countriesData[id].name] = id;
        idToCountryNameMap[id] = countriesData[id].name;
      });

      Object.keys(countriesData).forEach((id) => {
        const country = countriesData[id];
        if (country.lat && country.lon) {
          countryCentroids[country.name] = [country.lon, country.lat];
        }
      });

      const world = Globe()
        .globeImageUrl("water-texture.png")
        .backgroundImageUrl("./night-sky.png")
        .backgroundColor("black")(document.getElementById("globeViz"));

      world
        .polygonsData(worldData.features)
        .polygonCapColor(() => "#183eb4")
        .polygonSideColor(() => "rgba(0, 0, 0, 0.0)")
        .polygonStrokeColor(() => "#020a73")
        .onPolygonClick((feature) => showCountryInfo(feature.properties.name));

      const countryNames = worldData.features.map((f) => f.properties.name).sort();
      const select1 = new Choices("#country1", {
        searchEnabled: true,
        removeItemButton: true,
        placeholderValue: "Selecciona país de origen",
      });
      const select2 = new Choices("#country2", {
        searchEnabled: true,
        removeItemButton: true,
        placeholderValue: "Selecciona país destino",
      });
      select1.setChoices(countryNames.map((name) => ({ value: name, label: name })));
      select2.setChoices(countryNames.map((name) => ({ value: name, label: name })));

      document.getElementById("generateArc").addEventListener("click", () => {
        const country1 = select1.getValue(true);
        const country2 = select2.getValue(true);
        const criteria = document.getElementById("criteria").value;

        if (!country1 || !country2 || country1 === country2) {
          alert("Selecciona dos países diferentes");
          return;
        }

        const id1 = countryNameToIdMap[country1];
        const id2 = countryNameToIdMap[country2];
        const path = dijkstraPath(flightGraph, id1, id2, criteria);

        if (!path.length) {
          alert("No existe una ruta entre estos países.");
          return;
        }

        let totalPrice = 0;
        let totalDistance = 0;
        let totalTime = 0;
        arcsData = [];

        for (let i = 0; i < path.length - 1; i++) {
          const fromId = path[i];
          const toId = path[i + 1];
          const connection = flightGraph[fromId].connections[toId];

          totalPrice += connection.price_usd;

          const fromName = idToCountryNameMap[fromId];
          const toName = idToCountryNameMap[toId];
          const start = countryCentroids[fromName];
          const end = countryCentroids[toName];

          if (start && end) {
            const startPoint = turf.point(start);
            const endPoint = turf.point(end);
            const distance = turf.distance(startPoint, endPoint);
            totalDistance += distance;
            totalTime += distance / 900; // Tiempo en horas a 900 km/h
            arcsData.push({
              startLat: start[1],
              startLng: start[0],
              endLat: end[1],
              endLng: end[0],
              color: `hsl(${Math.random() * 360}, 70%, 50%)`,
            });
          }
        }

        world
          .arcsData(arcsData)
          .arcAltitudeAutoScale(0.5)
          .arcStroke(0.5)
          .arcDashLength(0.1)
          .arcDashGap(0.03)
          .arcDashAnimateTime(3000);

        const routeNames = new Set(path.map((id) => idToCountryNameMap[id]));
        world.polygonCapColor((feature) =>
          routeNames.has(feature.properties.name) ? "#386ee4" : "#183eb4"
        );

        showTripInfo(country1, country2, totalPrice, totalDistance, path);
      });
    });

    function showTripInfo(from, to, price, distance, path) {
      const infoBox = document.getElementById("tripInfo");
      const flightTime = (distance / 900).toFixed(1);
      const stops = path.map((id) => idToCountryNameMap[id]).join(" → ");
      const criteria = document.getElementById("criteria").value;
      
      let optimizedBy = "";
      switch (criteria) {
        case 'price': optimizedBy = "precio"; break;
        case 'distance': optimizedBy = "distancia"; break;
        case 'time': optimizedBy = "tiempo"; break;
      }

      infoBox.innerHTML = `
      <strong>Información del Viaje</strong>
      <p>Origen: ${from}</p>
      <p>Destino: ${to}</p>
      <p>Ruta optimizada por: ${optimizedBy}</p>
      <p>Ruta: ${stops}</p>
      <p>Precio total: $${price.toFixed(2)} USD</p>
      <p>Distancia total: ${distance.toFixed(2)} km</p>
      <p>Duración estimada: ${flightTime} horas</p>
    `;
      infoBox.style.display = "block";
    }

    function showCountryInfo(countryName) {
      const country = Object.values(countriesData).find((c) => c.name === countryName);
      if (!country) return;

      const modal = document.getElementById("countryModal");
      modal.innerHTML = `
      <div class="modal-content">
        <span class="modal-close">&times;</span>
        <h3>${country.spanish_name}</h3>
        <p><strong>Descripción:</strong> ${country.info.description}</p>
        <p><strong>Clima:</strong> ${country.info.climate}</p>
        <p><strong>Atracciones:</strong> ${country.info.attractions.join(", ")}</p>
        <p><strong>Curiosidades:</strong> ${country.info.curiosities.join(", ")}</p>
      </div>
    `;
      modal.style.display = "block";

      modal.querySelector(".modal-close").addEventListener("click", () => {
        modal.style.display = "none";
      });
    }
  </script>
</body>

</html>
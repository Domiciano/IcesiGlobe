<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Icesi Globe</title>
  <link href="css/css2.css" rel="stylesheet" />
  <script src="js/turf.min.js"></script>
  <link rel="stylesheet" href="css/index.css" />
</head>

<body>
  <header>Icesi Globe</header>
  <div id="globeViz"></div>

  <div class="controls">
    <select id="country1" class="country-select"></select>
    <select id="country2" class="country-select"></select>
    <div class="optimization-criteria">
      <label for="criteria">Optimizar por:</label>
      <select id="criteria">
        <option value="price" selected>Precio</option>
        <option value="distance">Distancia</option>
        <option value="time">Tiempo</option>
      </select>
    </div>
    <button id="generateArc">Generar Ruta</button>
    <button id="clearRoute" class="clear-button">Limpiar Ruta</button>
  </div>

  <div id="countryModal" class="modal"></div>
  <div id="tripInfo" class="trip-info"></div>

  <script src="js/globe.js"></script>

  <script>
    let arcsData = [];
    let countriesData = {};
    let flightGraph = {};
    let countryCentroids = {};
    let countryNameToIdMap = {};
    let idToCountryNameMap = {};

    function calculateWeight(connection, criteria) {
      switch (criteria) {
        case 'price':
          return connection.price_usd;
        case 'distance':
          const fromName = idToCountryNameMap[connection.from];
          const toName = idToCountryNameMap[connection.to];
          const start = countryCentroids[fromName];
          const end = countryCentroids[toName];
          if (start && end) {
            const startPoint = turf.point(start);
            const endPoint = turf.point(end);
            return turf.distance(startPoint, endPoint);
          }
          return connection.price_usd;
        case 'time':
          const fromCountry = idToCountryNameMap[connection.from];
          const toCountry = idToCountryNameMap[connection.to];
          const startPos = countryCentroids[fromCountry];
          const endPos = countryCentroids[toCountry];
          if (startPos && endPos) {
            const startPt = turf.point(startPos);
            const endPt = turf.point(endPos);
            const dist = turf.distance(startPt, endPt);
            
            return dist / 900;
          }
          return connection.price_usd / 100;
        default:
          return connection.price_usd;
      }
    }

    function dijkstraPath(graph, sourceId, destinationId, criteria = 'price') {
      const distances = {};
      const previous = {};
      const heap = [];

      for (const node in graph) {
        distances[node] = Infinity;
      }

      distances[sourceId] = 0;
      heap.push({ id: sourceId, distance: 0 });

      while (heap.length > 0) {
        heap.sort((a, b) => a.distance - b.distance);
        const { id: currentId, distance: currentDistance } = heap.shift();

        if (currentId === destinationId) break;
        if (!graph[currentId]?.connections) continue;

        for (const [neighborId, connection] of Object.entries(
          graph[currentId].connections
        )) {
          const connectionWithFromTo = {
            ...connection,
            from: currentId,
            to: neighborId
          };
          const edgeWeight = calculateWeight(connectionWithFromTo, criteria);
          const totalDistance = currentDistance + edgeWeight;

          if (totalDistance < distances[neighborId]) {
            distances[neighborId] = totalDistance;
            previous[neighborId] = currentId;
            heap.push({ id: neighborId, distance: totalDistance });
          }
        }
      }

      if (distances[destinationId] === Infinity) return [];

      const path = [];
      let current = destinationId;
      while (current !== sourceId) {
        path.push(current);
        current = previous[current];
        if (!current) return [];
      }
      path.push(sourceId);
      return path.reverse();
    }

    Promise.all([
      fetch("data/countries.json").then((res) => res.json()),
      fetch("data/realistic_flight_graph.json").then((res) => res.json()),
      fetch("data/world_with_ids.json").then((res) => res.json()),
    ]).then(([countries, graph, worldData]) => {
      countriesData = countries;
      flightGraph = graph;

      Object.keys(countriesData).forEach((id) => {
        countryNameToIdMap[countriesData[id].name] = id;
        idToCountryNameMap[id] = countriesData[id].name;
      });

      Object.keys(countriesData).forEach((id) => {
        const country = countriesData[id];
        if (country.lat && country.lon) {
          countryCentroids[country.name] = [country.lon, country.lat];
        }
      });

      const world = Globe()
        .globeImageUrl("water-texture.png")
        .backgroundImageUrl("./night-sky.png")
        .backgroundColor("black")(document.getElementById("globeViz"));
      
      window.world = world;

      function centerGlobeView(points) {
        if (!points || points.length === 0) return;
        
        if (points.length === 1) {
          const [lng, lat] = points[0];
          world.pointOfView({ lat, lng, altitude: 2.5 }, 1000);
          return;
        }
        
        let sumLat = 0, sumLng = 0;
        points.forEach(point => {
          sumLng += point[0];
          sumLat += point[1];
        });
        
        const avgLng = sumLng / points.length;
        const avgLat = sumLat / points.length;
        
        let maxDist = 0;
        for (let i = 0; i < points.length; i++) {
          for (let j = i + 1; j < points.length; j++) {
            const startPoint = turf.point(points[i]);
            const endPoint = turf.point(points[j]);
            const dist = turf.distance(startPoint, endPoint);
            maxDist = Math.max(maxDist, dist);
          }
        }
        
        const altitude = Math.max(1.5, Math.min(4, 1.5 + maxDist / 5000));
        
        world.pointOfView({ lat: avgLat, lng: avgLng, altitude }, 1000);
      }

      world
        .polygonsData(worldData.features)
        .polygonCapColor(() => "#183eb4")
        .polygonSideColor(() => "rgba(0, 0, 0, 0.0)")
        .polygonStrokeColor(() => "#020a73")
        .onPolygonClick((feature) => showCountryInfo(feature.properties.name));

      let countryNames = [];
      
      if (worldData.features && worldData.features.length > 0) {
        countryNames = worldData.features.map((f) => f.properties.name).sort();
      } else {
        countryNames = Object.values(countriesData).map(country => country.name).sort();
      }
      
      const country1Select = document.getElementById("country1");
      const country2Select = document.getElementById("country2");
      
      country1Select.innerHTML = '<option value="" disabled selected>País de origen</option>';
      country2Select.innerHTML = '<option value="" disabled selected>País de destino</option>';
      
      countryNames.forEach((name, index) => {
        const option1 = document.createElement('option');
        option1.value = name;
        option1.textContent = name;
        country1Select.appendChild(option1);
        
        const option2 = document.createElement('option');
        option2.value = name;
        option2.textContent = name;
        country2Select.appendChild(option2);
      });

      document.getElementById("generateArc").addEventListener("click", () => {
        const country1 = country1Select.value;
        const country2 = country2Select.value;
        const criteria = document.getElementById("criteria").value;

        if (!country1 || !country2 || country1 === country2) {
          alert("Selecciona dos países diferentes");
          return;
        }

        const id1 = countryNameToIdMap[country1];
        const id2 = countryNameToIdMap[country2];
        const path = dijkstraPath(flightGraph, id1, id2, criteria);

        if (!path.length) {
          alert("No existe una ruta entre estos países.");
          return;
        }

        let totalPrice = 0;
        let totalDistance = 0;
        let totalTime = 0;
        arcsData = [];
        const routePoints = [];

        for (let i = 0; i < path.length - 1; i++) {
          const fromId = path[i];
          const toId = path[i + 1];
          const connection = flightGraph[fromId].connections[toId];

          totalPrice += connection.price_usd;

          const fromName = idToCountryNameMap[fromId];
          const toName = idToCountryNameMap[toId];
          const start = countryCentroids[fromName];
          const end = countryCentroids[toName];

          if (start && end) {
            if (!routePoints.includes(start)) routePoints.push(start);
            if (!routePoints.includes(end)) routePoints.push(end);
            
            const startPoint = turf.point(start);
            const endPoint = turf.point(end);
            const distance = turf.distance(startPoint, endPoint);
            totalDistance += distance;
            totalTime += distance / 900;
            arcsData.push({
              startLat: start[1],
              startLng: start[0],
              endLat: end[1],
              endLng: end[0],
              color: `hsl(${Math.random() * 360}, 70%, 50%)`,
            });
          }
        }

        world
          .arcsData(arcsData)
          .arcAltitudeAutoScale(0.5)
          .arcStroke(0.5)
          .arcDashLength(0.1)
          .arcDashGap(0.03)
          .arcDashAnimateTime(3000);

        const routeNames = new Set(path.map((id) => idToCountryNameMap[id]));
        world.polygonCapColor((feature) =>
          routeNames.has(feature.properties.name) ? "#386ee4" : "#183eb4"
        );

        centerGlobeView(routePoints);

        showTripInfo(country1, country2, totalPrice, totalDistance, path);
      });
    });

    function showTripInfo(from, to, price, distance, path) {
      const infoBox = document.getElementById("tripInfo");
      const flightTime = (distance / 900).toFixed(1);
      const stops = path.map((id) => idToCountryNameMap[id]).join(" → ");
      const criteria = document.getElementById("criteria").value;
      
      let optimizedBy = "";
      switch (criteria) {
        case 'price': optimizedBy = "precio"; break;
        case 'distance': optimizedBy = "distancia"; break;
        case 'time': optimizedBy = "tiempo"; break;
      }

      infoBox.innerHTML = `
      <strong>Información del Viaje</strong>
      <p>Origen: ${from}</p>
      <p>Destino: ${to}</p>
      <p>Ruta optimizada por: ${optimizedBy}</p>
      <p>Ruta: ${stops}</p>
      <p>Precio total: $${price.toFixed(2)} USD</p>
      <p>Distancia total: ${distance.toFixed(2)} km</p>
      <p>Duración estimada: ${flightTime} horas</p>
      <button id="closeTripInfo" style="margin-top: 10px; width: 100%;">Cerrar</button>
    `;
      infoBox.style.display = "block";
      
      document.getElementById("closeTripInfo").addEventListener("click", () => {
        infoBox.style.display = "none";
      });
    }

    function showCountryInfo(countryName) {
      const country = Object.values(countriesData).find((c) => c.name === countryName);
      if (!country) return;

      const modal = document.getElementById("countryModal");
      modal.innerHTML = `
      <div class="modal-content">
        <span class="modal-close">&times;</span>
        <h3>${country.spanish_name}</h3>
        <p><strong>Descripción:</strong> ${country.info.description}</p>
        <p><strong>Clima:</strong> ${country.info.climate}</p>
        <p><strong>Atracciones:</strong> ${country.info.attractions.join(", ")}</p>
        <p><strong>Curiosidades:</strong> ${country.info.curiosities.join(", ")}</p>
      </div>
    `;
      modal.style.display = "block";

      modal.querySelector(".modal-close").addEventListener("click", () => {
        modal.style.display = "none";
      });
    }
    
    window.addEventListener('resize', () => {
      if (arcsData.length > 0) {
        const routePoints = [];
        arcsData.forEach(arc => {
          const startPoint = [arc.startLng, arc.startLat];
          const endPoint = [arc.endLng, arc.endLat];
          if (!routePoints.includes(startPoint)) routePoints.push(startPoint);
          if (!routePoints.includes(endPoint)) routePoints.push(endPoint);
        });
        
        if (typeof centerGlobeView === 'function' && routePoints.length > 0) {
          centerGlobeView(routePoints);
        }
      }
    });
    
    // ------------ Para dispositivos móviles ------------
    document.addEventListener('touchstart', (e) => {
      const modal = document.getElementById("countryModal");
      const tripInfo = document.getElementById("tripInfo");
      const controls = document.querySelector('.controls');
      
      if (modal.style.display === 'block' && 
          !modal.contains(e.target) && 
          e.target !== modal) {
        modal.style.display = 'none';
      }
      
    });

    function setupTouchInteractions() {
      document.getElementById('globeViz').addEventListener('touchmove', function(e) {
        if (e.touches.length > 1) {
          e.preventDefault();
        }
      }, { passive: false });
      
      window.addEventListener('orientationchange', function() {
        setTimeout(() => {
          if (arcsData.length > 0) {
            const routePoints = [];
            arcsData.forEach(arc => {
              const startPoint = [arc.startLng, arc.startLat];
              const endPoint = [arc.endLng, arc.endLat];
              if (!routePoints.includes(startPoint)) routePoints.push(startPoint);
              if (!routePoints.includes(endPoint)) routePoints.push(endPoint);
            });
            
            if (typeof centerGlobeView === 'function' && routePoints.length > 0) {
              centerGlobeView(routePoints);
            }
          }
        }, 300);
      });
    }
    
    function updateMobileUI() {
      const isMobile = window.innerWidth < 768 || /Mobi|Android/i.test(navigator.userAgent);
      
      if (isMobile) {
        document.body.classList.add('mobile-device');
      } else {
        document.body.classList.remove('mobile-device');
      }
    }
    
    // ------------ Función de borrar ruta ------------

    document.addEventListener('DOMContentLoaded', function() {
      setupTouchInteractions();
      updateMobileUI();
      
      document.getElementById('clearRoute').addEventListener('click', clearCurrentRoute);
      
      document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
          clearCurrentRoute();
        }
      });
    });
    
    function clearCurrentRoute() {
      const country1Select = document.getElementById("country1");
      const country2Select = document.getElementById("country2");
      country1Select.selectedIndex = 0;
      country2Select.selectedIndex = 0;
      
      const tripInfo = document.getElementById("tripInfo");
      tripInfo.style.display = "none";
      
      const countryModal = document.getElementById("countryModal");
      countryModal.style.display = "none";
      
      if (window.world) {
        window.world.arcsData([]);
        
        window.world.polygonCapColor(() => "#183eb4");
        window.world.pointOfView({ lat: 0, lng: 0, altitude: 2.5 }, 1000);
      }
      
      arcsData = [];
    }
    
    window.addEventListener('resize', updateMobileUI);
  </script>
</body>

</html>